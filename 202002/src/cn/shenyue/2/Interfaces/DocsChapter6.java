public class DocsChapter6 {
    /**
     * 接口： 主要用来描述类具有什么功能，而并不给出每个功能的实现
     * lambda表达式： 一种表示可以在将来某个时间点执行的代码块的简洁方法
     * 6.1 接口
     *  1. 接口不是类，而是对类的一组需求描述
     *  2. 接口中的所有方法自动地属于public，在接口中声明方法时可不用提供关键字public
     *  3. 接口中不能含有实例域， Java 8 以前也不能在接口中实现方法
     *  5. 类实现一个接口通常有两个步骤：
     *      1.将类声明为实现给定的接口， 需要使用关键字 implements
     *      2.对接口中的所有方法进行定义
     *  6. 在实现接口时，必须将方法声明为public
     *  7. 不能使用new运算符实例化一个接口
     *  8. 能声明接口变量，接口变量必须引用实现了接口的类对象
     *  9. 也可以使用instanceof检查一个对象是否属于某个特定的接口
     *  10. 接口也可以被继承
     *  11. 接口中不能包含实例域或静态方法，但却可以包含常量，接口中的域会被自动设为public static final
     *  12. 每个类只能拥有一个超类，但却可以实现多个接口，用逗号隔开
     *  13. Java 8 中，允许在接口中增加静态方法
     *  14. 可以为接口方法提供一个默认实现，用default修饰符标记这样一个方法，默认方法可以调用任何其他方法
     *  15. 默认方法冲突（接口和接口、接口和超类之间定义了同样的方法）
     *          1.超类优先，如果超类提供了一个具体方法，则会忽视接口中提供的同名且参数相同的默认方法，类优先的原则
     *              可以确保与Java 7的兼容性，即即使在接口中新增默认方法，也不会影响到原来正常工作的代码
     *          2.接口冲突
     *              1.如果一个超接口提供了一个默认方法，另一个接口提供了一个同名且参数类型相同的方法，必须
     *              覆盖这个方法来解决冲突
     *              2.只要有一个接口提供了默认实现，那么编译器就会报错，必须解决这个二义性
     *              3.如果都没有提供默认实现，那么可以 1.实现 2. 不是实现（这个类本事就是抽象的）
     *              4.如果覆盖方法时需要引用接口的默认方法，需要interface.super.getName()调用
     *  16. 不要在接口中默认方法重新定义Object类中的某个方法，因为类优先原则
     * 6.2 接口示例
     *  1. java.swing.Timer类，可以使用它在到达给定的时间间隔时发出通告
     *  2. 定时器调用的方法所在的对象的所属类需要实现java.awt.event包的ActionListener接口
     *      public interface ActionListener {void actionPerformed(ActionEvent event);}
     *     当到达指定时间间隔，定时器就会调用actionPerformed方法
     *  3. 对一个对象数组排序，前提是这些对象是实现了Comparable接口的类的实例，例如对一个字符串数组排序，是
     *      因为String类实现了Comparable<String>,而且String.CompareTo方法可以按字典顺序比较字符串
     *  4. Arrays.sort方法还有第二个版本，有一个数组和一个比较器作为参数，比较器是实现了Comparator接口的类的实例
     *      public interface Comparator<T> { int compare(T first, T second);}
     *  5. 对象克隆接口Cloneable接口，这个接口指示一个类提供了一个安全的clone方法
     *  6. Object.clone() 方法是protected，说明不能直接调用这个方法。只有Employee类可以克隆Employee对象
     *  7. 默认的克隆操作时浅拷贝，如果原对象和浅克隆对象共享的子对象不是可变的，那么这种共享就是安全的
     *  8. 如果子对象是可变的，必须重新定义clone方法来建立一个深拷贝，同时克隆所有子对象
     *  9. 对于每一个类，需要确实：
     *      1. 默认的clone方法是否满足要求
     *      2. 是否可以在可变的子对象上调用clone来修补默认的clone方法
     *      3. 是否不该使用clone
     *  10. 所有数组类型都有一个public的clone方法，而不是protected
     * 6.3 lambda表达式
     *  1. 引入原因： 在Java中传递一个代码段并不容易，不能直接传递代码段，必须构造一个对象
     *  2. (String first, String second) -> first.length() - second.length();
     *  3. lambda表达式就是一个代码块，以及必须传入代码的变量规范
     *  4. 表达式形式
     *      1. 由参数、箭头、以及一个表达式
     *      2. 无法放在一个表达式内，可以将这些代码放在{}中
     *      3. 即使没有参数，仍要提供一个空括号
     *      4. 如果可以推导出一个lambda表达式的类型，则可以忽略其类型
     *      5. 如果只有一个参数并且类型可以推导出来，那么还可以省略小括号
     *      6. 无需指定lambda表达式的类型，返回类型总是有上下午推导得出
     *
     */
}
